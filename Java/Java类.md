[toc]

# 类

## 构造器 （constructor）

**构造方法幼教构造器， 是类的一种特殊的方法， 他的主要作用是完成新对象的初始化。**

**【】表示可写可不写**

### 语法

【修饰符】方法名(形参列表) {

​	方法体

}

### 说明

1. 构造器的修饰符可以默认  => public protected private
2. 构造器没有返回值
3. 方法名和类名称必须一样
4. 参数列表和 成员方法 一样的规则
5. 构造器的调用系统完成

### 使用细节

1. 一个类可以定义多个不同的构造器， 即构造器重载

   比如：我们可以再给Person类定义一个构造器， 用来创建对象的时候， 只指定人名， 不需要指定年龄

2. 构造器名要和类名相同

3. 构造器没有返回值

4. 构造器是完成对象的初始化，并不是创建对象

5. 在创建对象时，系统自动的调用该类的构造方法

6. 如果程序员没有定义构造方法， 系统会自动给类生成一个默认无参构造方法(也叫默认构造方法)， 如如Person(){}，使用javap指令反编译试试

7. 一旦定义了自己的构造器， 默认的构造器就覆盖了， 就不能再使用默认无参构造器， 除非显示的定义一下， 即： Person(){}

---

## 对象创建流程

~~~ java
class Person{
    String name;
    int age = 90;
    Person(String n, int a){
        name = n;
        age = a
    }
}
Person p = new Person("小明", 18)
~~~

### 流程分析

1. 加载Person类信息（Person.class），只会加载一次（在方法区）
2. 在堆中分配空间（地址）
3. 完成对象默认初始化  => name = null      age = 0
4. 显示初始化  =>  name =  null      age = 90
5. 构造器的初始化  =>  name = 小明      age = 18
6. 对象在堆中的地址，返回给p（p是对象名 => 也可以叫对象的引用）

---

## 引出this

~~~java
class Person {
    String name;
    int age;
    public Person(String dName, int dAge){
        name = dName;
        age = dAge;
    }
}
~~~

上面的类初始化是没有问题的，只是在构造器中的  name = dName 很不优雅，这样会起很多没必要的名字，但是如果直接把形参换成name然后通过 name = name 的话，这个name又取不到Person上的属性， 这时候我们就可以使用this

~~~java
class Person {
    String name;
    int age;
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
}
~~~

这样写代码就比较优雅了

### 什么是this

java虚拟机会给每个对象分配this， 这个this代表当前对象。

简单来说， 哪个对象调用， this就指向哪个对象

**可以通过hashCode来返回该对象的内存地址转换成的整数**

### this的使用细节

1. this关键字可以用来访问本类的属性、方法、构造器
2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法： this.方法名（参数列表）
4. 访问构造器语法：this（参数列表） => **注意稚嫩恶搞在构造器中使用（即只能在构造器中访问另一个构造器， 且必须放在第一条语句， 这和继承有关系）**
5. this不能再类定义的外部使用， 只能在类定义的方法中使用

---

## 访问修饰符

#### 访问权限

Java提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限

1. 公开级别：用 **public** 修饰，对外公开
2. 受保护级别：用 **protected** 修饰，对子类和同一个包中的类 公开
3. 默认级别：没有修饰符号，向同一个包的类公开，子类不可用
4. 私有级别：用 **private** 修饰，只有类本身可以访问，不对外公开

#### 使用访问修饰符的注意事项

1. 修饰符可以用来修饰类中的属性、成员方法以及类

2. **只有默认的和 public 才能修饰类！**并且遵循上述访问权限的特点

3. 子类（待补充）

4. 成员方法的访问规则和属性完全一样

   // com.hspedu.modifier: 需要很多文件来说明（A类、B类、Test类）

---

## 面向对象

属性如果不赋值, 有默认值, 与数组保持一致

### 封装（encapsulation）

**封装就是把抽象出的数据和对数据 [ 属性 ] 的操作 [ 方法 ] 封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作 [ 方法 ] ，才能对数据进行操作**

#### 好处

1. 隐藏实现细节	

   可以写好方法，使用时直接调用就可以

2. 可以对数据进行验证，保存安全合理

#### 实现步骤

1. 将属性进行私有化 private	=>	不能再外部直接修改属性
2. 提供一个公共的（public）set方法，用于对属性判断并赋值

~~~java
public void xxx(类型 参数名){
    //加入数据验证的业务逻辑
    属性 = 参数名
}
~~~

3. 提供一个公共的（public）get方法，用于获取属性的值

~~~java
public 数据类型 getXxx(){//权限判断，Xxx某个属性
    return XX
}
~~~

### 继承（extends）

**在两个类的属性和方法很多都是相同的时候，我们可以不必每次都重新写过，这样的话代码的冗余度太高，可以通过继承来创建另一个类**

**继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可**

#### 基本语法

~~~java
class 子类 extends 父类 {

}
~~~

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫超类、基类
3. 子类又叫派生类

#### 好处

1. 代码的复用性提高了
2. 代码的扩展性和维护性提高了

#### 细节

1. 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，要通过公共的方法区访问

2. 子类必须调用父类的构造器，完成父类的初始化

   **先调用父类的构造器，然后在调用子类的构造器**

3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中使用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)

5. super() 在使用时，必须放在构造器第一行

   **super() 只能在构造器中使用, 但是super可以在非构造器中使用**

   **super() 是访问父类的构造器**

6. super() 和 this() 都只能放在构造器第一行， 因此这两个方法不能共存在一个构造器

7. java所有类都是Object类的子类（派生类），Object是所有类的父类（基类）

8. **父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）**

9. 子类最多只能继承一个父类(指直接继承)，即java中是单继承机制。

   思考：如何让A类继承B类和C类

   **可以让B类先去继承C类，然后再用A类继承B类， 就实现了A类同时继承B类和C类**

10. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

    is-a: Person is a Music ? 

    ​		Person 和 Music 并没有直接关系 所以 如果想要 Music extends Person 是不合理的

    ​		Animal

    ​		Cat extends Animal 	Cat 属于 Animal 所以是合理的

#### 本质 

##### new 一个继承过的类时 内存中发生了什么， 内存布局

 	1. 首先加载 Object 类信息（在方法区加载），因为 Object 是顶级父类，最先加载，然后从上到下一级一级加载，形成类的继承关系
 	2. 只会在堆中分配一块空间, 从上到下 一级一级初始化属性到这一块空间内，重复属性不覆盖，因为它们属于不同的类，而是创建不同空间存起来

##### 当我们通过new出来的子类去访问属性时 

	1. 首先看子类是否有改属性
	2. 如果子类有这个属性，并且可以访问，则返回信息
	3. 如果子类有这个属性，但是不能访问，就会报错
	4. 如果子类没有这个属性，就看父类有没有这个属性，如果父类有该属性并且可以访问，就返回信息
	5. 如果父类没有就按照(4)的规则，继续找上级父类，直到Object...  
	6. 如果都没有就会报错

![](D:\study\markdown\Java\images\Java继承-new子类时内存分布.png)

#### super关键字

**super 代表父类的引用，用于访问父类的属性、方法、构造器**

##### 基本语法

1. 访问父类的属性，但不能访问父类的 private 属性

   super.属性名、

2. 访问父类的方法，不能访问父类的 private 方法

   super.方法名（参数列表）

3. 访问父类的构造器（这点前面用过）

   super(参数列表)；只能放在构造器的第一句，且只能出现一句

##### super给编程带来的便利/细节

1. 调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）
2. 当子类中有和父类中的成员（属性和方法）重名时，问了访问父类的成员，必须通过 super。如果没有重名，使用 super、this、直接访问是一样的效果！
3. super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用 super 访问遵循就近原则。

##### super 和 this 的比较

1. 访问属性
   - this：访问本类中的属性，如果本类没有此属性则从父类中继续查找
   - super：从父类开始查找属性
2. 调用方法
   - this：访问本类中的方法，如果本类没有此方法则从父类继续查找
   - super：从父类开始查找方法
3. 调用构造器
   - this：调用本类构造器，必须放在构造器的首行
   - super：调用父类构造器，必须放在子类构造器的首行
4. 特殊
   - this：表示当前对象
   - super：子类中访问父类对象

#### 方法重写/覆盖(override)

##### 概述

方法覆盖就是子类有一个方法,和弗雷的某个方法的名称、返回类型、参数一样, 那么我们就说子类的这个方法覆盖了父类的方法

##### 细节

1. 子类的方法的参数,方法名称,要和父类方法的参数,方法名称完全一样
2. 子类方法的返回类型和父类方法返回类型一样, 或者是父类返回类型的子类

​	比如: 父类的返回类型是Object, 子类方法返回类型是String

~~~java
//父类
class parent {
    public Object getInfo(){}
}

//子类
class children extends parent {
    public String getInfo(){}
}

//这样会触发重写 因为String是Object的子类
//如果children里的getInfo的返回类型也是Object也会触发重写
//如果parent的getInfo返回类型是String, 而children的getInfo的返回类型是是Object会编译错误
~~~



3. 子类方法不能缩小父类方法的访问权限

~~~java
//父类
class parent {
    public void eat(){}
}

//子类
class children extends parent {
    protected void eat(){} // 报错, 缩小了父类方法的访问权限
}
~~~

##### 重载和重写

1. 发生范围

	- 重载: 本类
	- 重写: 父子类

2. 方法名

- 重载: 必须一样
- 重写: 必须一样

3. 形参列表

- 重载: 类型,个数或者顺序至少有一个不同
- 重写: 相同

4. 返回类型

- 重载: 无要求
- 重写: 子类重写的方法返回的类型和父类方法返回的类型一样或者是其子类

5. 修饰符

- 重载: 无要求
- 重写: 子类方法不能缩小父类方法的访问范围

### 多态

#### 概述

我的 => 调用一个类的方法时传的参数类型不一样每次都要对方法进行一次重载, 这就导致了代码的冗余,这样的代码复用性不高,而且不利于代码维护

基本介绍: 方法或对象具有多种形态,是面向对象的第三大特征,多态是简历在封装和继承基础之上的

#### 具体体现

1. 方法的多态

   重载和重写就体现多态

2. 对象的多态

   1. 一个对象的编译类型和运行类型可以不一致
   2. 编译类型在定义对象时就确定了,不能改变
   3. 运行类型是可以变化的
   4. 编译类型看定义时 = 号的左边, 运行类型看= 号的右边

   **父类的对象引用可以指向子类的对象, 并且在运行时以运行类型为主, 如下**

   ```java
   Animal animal = new Dog(); // animal 编译类型是Animal, 运行类型是Dog
   animal = new Cat(); // animal运行类型变成了Cat, 编译类型仍然是Aniaml
   ```

   