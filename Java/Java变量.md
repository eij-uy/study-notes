[TOC]



# Java变量

## 数据类型及其占用空间

### 基本数据类型

**基本数据类型放在栈里**

#### 整数类型

**Java的整型常量默认为int型, 生命long型常亮需在后面加上l 或者 L**

**Java程序中变量常声明为int型, 除非不足以表示大数, 才使用long**

**bit: 计算机中的最小存储单位, byte: 计算机中基本存储单元, 1byte = 8 bit.**

- byte => 1个字节 -128 ~ 127
- short => 2个字节 -2(2^15)~(2^15) - 1 -32768 ~ 32767
- int => 4个字节 
- long => 8个字节

#### 浮点数类型

**浮点数= 符号位 + 指数位 + 尾数位**

**尾数不问可能丢失, 造成精度损失(小数都是近似值)**

**Java的浮点型常亮默认为double型, 声明float型常亮, 需在后面加上f 或者 F**

- float => 4个字节
- double => 8个字节

#### 字符型

- chart => 2个字节

#### 布尔型

- boolean => 1个字节

### 引用数据类型

**引用类型存在栈里的是一个指向堆的地址**

#### 类 => class

#### 接口 => interface

#### 数组 => []

细节:

1. 数组是多个相同类型数据的组合, 实现对这些数据的统一管理
2. 数组中的蒜素可以是任何数据类型, 包括基本类型和引用类型, 但是不能混用
3. 数组创建后, 如果没有赋值, 有默认值( int: 0, short: 0, byte: 0, long: 0, float: 0.0, double: 0.0, char: \u000, boolean: false, String: null )
4. 使用数组的步骤: 1. 声明数据并开辟空间 2. 给数据各个元素赋值 3. 使用数组
5. 数组的下标是从0开始的
6. 数组下标必须在指定范围内使用, 否则报: 下标越界异常, 比如: int[] arr = new int[5]; 则有效下标为0-4
7. 数组属于引用类型, 数组型数据是对象( object )

**java中定义的数组如果没有初始化, 直接使用下标赋值会报错 => 空指针异常**

定义数组:  数据类型[] 数据名 || 数据类型 数据名[]

数组初始化: 

- 动态初始化

       1. 数据类型[] 数据名 = new 数据类型[大小]
       1. 数据类型 数据名[] = new 数据类型[大小]
       1. 数据类型[] 数据名;  然后在数据名 = new 数据类型[大小]
       1. 数据类型 数据名[]; 然后在数据名 = new 数据类型[大小]

- 静态初始化

1. 数据类型[] 数组名 = { 元素值, 元素值 }
2. 数据类型 数组名[] = { 元素值, 元素值 }

**多维数组**

定义: 同上普通数组, 定义时左边的[]根据几维数组来写, 一维数组就一个[], 二维数组就两个[]

比如: int\[\]\[\] arr;  就是一个二维数组

初始化:  

- 动态初始化

1. 类型\[\]\[\]… 数组名 = new 類型\[大小\]\[大小\]…
2. 类型\[\]\[\]… 数组名; 然后 数组名 = new 類型\[大小\]\[大小\]…

如果二维数组中的一维数组长度不一样就不能用上面的方法进行初始化, 可以先不赋值大小, 直接写\[\], 然后通过循环进行添加

- 静态初始化

1. 类型\[\]\[\]… 数组名 = { { … },{ … } … }

## 类型转换

### 自动类型转换

**Java中, 精度小的类型可以自动转换成精度大的数据类型, 这个就是自动类型转换**

**下面是两个转换路径**

- chart => int => long => float => double

- byte => short => int => long => float => double

### 强制类型转换

**强转符号只针对于最近的操作数有效, 往往会使用小括号提升优先级**

在数据前加上要小括号, 在括号中加上转换成的类型名称

比如: int i = (int)1.9  => 1

## 运算符

### 位运算符

- \>\>  算术右移 

**算术右移规则: 低位溢出, 符号位不变, 并用符号位补溢出的高位**

**相当于每次除以2, 但是不准确, 例如下面的例子**

**1 \>\> 2  向右位移两位**

1的补码 = 00000000 00000000 00000000 00000001

1 \>\> 2 = 00000000 00000000 00000000 00000000 = 0

---

- \>\>\> 无符号右移 | 逻辑右移

**无符号右移运算规则: 低位溢出, 高位补0**

****

---

- \<\< 算术左移  同算术右移

**算术左移的运算规则: 符号位不变, 低位补0**

**相当于每次乘2, 但是不准确, 例如下面的例子**

**1 << 2 向左移动两位**

---

**没有<<<符号, 没有无符号左移!!!**

---

- ~-2 = ?  按位取反

**0 -> 1( 零变一 )  	1 -> 0 ( 一变零 )**

-2的原码 = 10000000 00000000 00000000 00000010  

-2的反码 = 11111111 11111111 11111111 11111101

-2的补码 = 11111111 11111111 11111111 11111110

~-2的补码 = 00000000 00000000 00000000 00000001

~-2的原码 = 00000000 00000000 00000000 00000001 = 1

**~2 = ?**

2的原码 = 00000000 00000000 00000000 00000010

2的补码 = 00000000 00000000 00000000 00000010

~2的补码= 11111111 11111111 11111111 11111101

~2的反码= 11111111 11111111 11111111 11111100

~2的原码= 10000000 00000000 00000000 00000011 = -3

---

- 2&3 = ? 2按位与3

**两位全为1, 结果为1, 否则为0**

先得到 2的补码 => 要先得到2的原码 

2是int类型, 四个字节, 最左边的0是符号位, 0代表正数

2的原码 = 00000000 00000000 00000000 00000010  

2的补码 = 00000000 00000000 00000000 00000010 

3的原码 = 00000000 00000000 00000000 00000011

3的补码 = 00000000 00000000 00000000 00000011

2按位与3的补码 = 00000000 00000000 00000000 00000010

2按位与3的原码 = 00000000 00000000 00000000 00000010 = 2

---

- 2|3 = ? 2按位或3

**两位有一个为1或都为1, 结果为1, 否则为0**

2的补码 = 00000000 00000000 00000000 00000010

3的补码 = 00000000 00000000 00000000 00000011

2|3的补码=00000000 00000000 00000000 00000011

2|3的原码=00000000 00000000 00000000 00000011 = 3

---

- -3^3 = ? 按位异或

两位一个为0, 一个为1, 结果为1, 否则为0

-3的原码= 10000000 00000000 00000000 00000011

-3的反码= 11111111 11111111 11111111 11111100

-3的补码= 11111111 11111111 11111111 11111101

3的原码 = 00000000 00000000 00000000 00000011

3的补码 = 00000000 00000000 00000000 00000011

-3^3的补码 = 11111111 11111111 11111111 11111110

-3^3的反码 = 11111111 11111111 11111111 11111101

-3^3的原码 = 10000000 00000000 00000000 00000010 = -2

****

#### 源码 反码 补码

**对于有符号的数而言, 符号位在二进制的最左边**

1.  二进制的最高位是符号位: 0表示正数, 1表示负数( 口诀: 0-> 1 1-> - )
2. 正数的原码, 反码, 补码都一样( 三码合一 )
3. 负数的反码 = 它的原码符号位不变, 其他位取反( 0->1, 1-> 0 )
4. 负数的补码 = 它的反码 + 1, 负数的反码 = 负数的补码 -1
5. 0的反码, 补码都是0
6. java没有无符号数, 换言之, java中的数都是有符号的
7. 在计算机运算的时候, 都是以**补码**的方式来运算的
8. 当我们看运算结果的时候, 要看他的**原码**

