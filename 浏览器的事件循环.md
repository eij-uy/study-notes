[TOC]





# 浏览器的事件循环

**浏览器是一个多进程多线程的应用程序**

**单线程是实现异步的原因，事件循环是异步的实现方式**

## 对于js异步的理解

js是一个单线程的语言, 这是因为它执行在浏览器的渲染主线程里, 渲染主线程只有一个, 渲染主线程承担着很多的任务, 其中就包括渲染页面和执行js等. 

**如果浏览器同步的去执行这些代码, 一旦遇到计时器, 事件监听之类的无法立即执行的任务的时候就会阻塞渲染主线程, 使消息队列中的其他任务无法执行, 这会让渲染主线程浪费很多时间, 也会导致页面无法更新, 给用户造成卡死现象**

**所以浏览器使用了异步的解决方案, 具体就是在某些任务发生的时候, 比如计时器, 网络请求, 监听事件等, 主线程会把任务交给其他线程去处理, 自己立即去执行消息队列中后续的任务, 在其他线程完成的时候, 会将事先传递的回调函数包装成任务, 放到消息队列的末尾, 等待主线程的执行**

**在这种异步模式下,浏览器将永不阻塞, 从而最大限度的保证了单线程的流畅运行**

## js为什么会阻碍渲染

例子:

```html
<h1>I'm a Programmer</h1>
<button>change</button>
<script>
    const h1 = document.querySelector('h1')
    const btn = document.querySelector('button')

    function delay(duration){
        const start = Date.now()
        while (Date.now() - start < duration){}
    }

    btn.onclick = () => {
        h1.textContent = 'I\'m a YuJie'
        delay(3000)
    }
</script>
```

首先, 浏览器渲染主线程执行js, 遇到给btn绑定点击事件时会调出另一个线程去监听, 当用户点击按钮时, 首先改变h1的文字, 然后进入3s的死循环, 但是浏览器上的文字是等3s以后在渲染成功的, 这是因为渲染主线程在执行点击事件的任务时虽然改变了h1的文字, 但是delay函数在3s内不断的向消息队列中加任务, 导致渲染页面的任务一直得不到渲染主线程的执行, 当死循环过后, 渲染页面的任务才得到执行, 这中间如果用户做了其他操作, 比如点击其他按钮, 也会加到消息队列末尾, 在执行完之前的页面渲染之后才会执行这次按钮的事件

## 任务有优先级吗

任务没有优先级, 在消息队列中先进先出,

**但是消息队列是有优先级的**

根据 w3c 的最新解释:

- 每个任务都有一个任务类型, 同一个类型的任务必须在一个队列, 不同类型的任务可以分属于不同的队列. 在一次事件循环中, 浏览器可以根据实际情况从不同的队列中取出任务执行

- 浏览器必须准备好一个微队列, 微队列中的任务优先所有其他任务执行

  ```js
  https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint
  ```


以前浏览器没有那么复杂，直接分成了宏队列和微队列， 但是现在浏览器变的很复杂了，宏队列和微队列已经不满足需求了， 所以现在有了很多的队列，+上面的w3c解释

**w3c官网认为用户交互任务很重要， 所以除了微队列，最先执行的应该是用户交互的任务**

## 阐述一下js的事件循环

- 事件循环又叫消息循环( **w3c官网中把这部分叫做event loop， 而chrome源码中把这个叫做message loop，所以有不同的叫法** )是浏览器渲染主线程的工作方式。

- 在Chrome的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务放到消息队列末尾即可。

- 过去把消息队列简单分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
- 根据w3c官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，**任务没有优先级，但是不同任务队列有不同的优先级**，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，**但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行**。

-----

## js中的计时器能做到精确计时吗？为什么？

不行，因为

1. 计算机硬件没有**原子钟**，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于js的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. **按照w3c的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会有四毫秒的最少时间，这样在计划时间少于四毫秒的时候又带来了偏差**
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差( **由另一个线程监听并放到消息队列的末尾，中间主线程处理其他任务会消耗时间** )
