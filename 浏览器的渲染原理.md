[TOC]

# 浏览器的渲染原理

## 什么叫渲染

把html字符串转换成浏览器上显示的像素信息的过程叫做渲染

## 浏览器输入url地址到页面呈现浏览器都干了些什么

- 网络： 浏览器通过网络进程中的一个线程去拿到html生成一个渲染任务给到消息队列末尾

- 渲染： 渲染

### 渲染流程

#### 渲染流程的阶段

HTML解析 => 样式计算 => 布局 => 分层 => 绘制 =>分块 => 光栅化 => 画

**每个阶段都有明确的输入输出,上一个阶段的输出会成为下一个阶段的输入,这样整个渲染流程就形成了一套组合严密的生产流水线**

1. **解析HTML**

解析HTML会生成两个树, 一个是DOM树, 一个是CSSOM树

- DOM树 ( document object model )
- CSSOM树 ( css object model )

有四种样式表,

- ```html
  <style></style> <!-- 内部样式表 -->
  ```

- ```html
  <link ...> <!-- 外部样式表 -->
  ```

- ```html
  <div style=""></div> <!-- 内联样式表 js操作dom的css多数是操作这个-->
  ```

- 浏览器默认样式表 => 规定了html,body,div,p等很多标签的默认样式

可以通过js操作dom除了操作dom的内联样式之外还可以通过document.styleSheets获取到除了浏览器默认样式表之外的所有样式信息,可以在这里更改

**我的理解: 渲染时首先会让预解析线程快速浏览一遍, 碰到css会让网络线程下载css然后返回给渲染主线程, 渲染主线程则会直接解析html, 碰到css则会略过, 等预解析线程将css返回回来之后在解析这一段css**



**该是怎样: 渲染的第一步是解析HTML, 解析过程中遇到css解析css, 遇到js执行js. 为了提高解析效率, 浏览器在开始解析前, 会启动一个预解析的线程, 率先下载HTML中的外部css文件和外部的js文件**

**如果主线程解析到link位置, 此时外部的css文件还没有下载解析时,主线程不会等待, 继续解析后续的HTML. 这是因为下载和解析css的工作是预解析线程中进行的. 这就是css不会阻塞HTML解析的根本原因**

**如果主线程解析到script位置, 会停止解析HTML, 转而等待js文件 下载完毕, 并将全局代码解析执行完成后, 才能继续解析HTML. 这是因为js代码的执行过程可能会修改当前的DOM树, 所以DOM树的生成必须暂停. 这就是js会阻塞HTML解析的根本原因**

**第一步完成后,会得到DOM树和CSSOM树, 浏览器的默认样式, 内部样式, 外部样式, 行内样式(内联样式)都会包含在CSSOM树中**

---

2. **样式计算**

#### css属性值的计算过程

- 层叠
- 集成

#### 视觉格式化模型

- 盒模型
- 包含块
- BFC
- 流式布局
- 浮动布局
- ...

主线程会遍历得到的DOM树,依次为树中的每个节点计算出最终的样式,称为Computed Style. 

在这一过程中, 很多预设值会变成绝对值, 比如red会变成rgb(255,0,0), 相对单位会变成绝对单位, 比如em会变成px

这一步完成后, 会得到一颗带有样式的DOM树

---

3. **布局 - Layout**

我的理解: 整个DOM树中根据每个节点的信息计算出尺寸和样式生成Layout树, Layout树和DOM树不一定一一对应, DOM树中display:none的节点不会在Layout树中存在, Layout树中不在是DOM对象, 而是转换过的对象

**内容只能放到行盒中, 行盒和块盒不能相邻, 会补充匿名盒子**

**布局阶段会依次遍历DOM树中的每一个节点, 计算每个节点的几何信息, 例如节点的宽高, 相对包含块的位置, 大部分的时候, DOM树和布局树并非一一对应, 比如display:none的节点没有几何信息, 因此不会生成到布局树, 又比如使用了伪元素选择器, 虽然DOM树中不存在这些伪元素节点, 但是它们拥有几何信息, 所以会生成到布局树中, 还有匿名行盒, 匿名行盒等等都会导致DOM树和布局树无法一一对应**

---

4. **分层  **

我的理解: 布局完成之后会对页面进行分层, 是为了页面改变时只改变那一部分就可以了, 不用全部改变, 不同浏览器或同个浏览器的不同版本对分层的策略不同, **堆叠上下文等有关的属性**会影响浏览器对分层的判断

**堆叠上下文等有关的属性**

- z-index
- opacity
- transform
- ...

**主线程会使用一套复杂的策略对整个布局树中进行分层**

**分层的好处在于, 将来某一个层改变后, 仅会对该层进行后续处理, 从而提升效率**

**滚动条, 层叠上下文, transform,opacity等样式都会或多或少的影响分层效果, 也可以通过will-change树形更大程度的影响分层结果**

**我们不能操作分层, 只能对浏览器进行一些提示, 由浏览器自行判断要不要分层**

---

5. **绘制**

**渲染主线程的工作到此为止, 剩余步骤交给其他线程完成**

渲染主线程:

解析HTML过程中产生DOM树, CSSOM树, 遇到js执行js, DOM树和CSSOM树交给样式计算, 计算完成之后会生成一个包含最终样式信息的DOM树, 然后进行布局,生成每个节点的几何信息, 变成布局树之后就和DOM树不一样了, 根据布局树进行分层,**分层之后对每一层生成绘制指令**, 然后主线程会把剩余的步骤交给其他线程

**主线程会为每个层单独产生绘制指令集, 用于描述这一层的内容该如何画出来**

---

6. **分块( Tiling ) : 将每一层分为很多小的区域**

**生成绘制指令集后,主线程将每个图层的绘制信息提交给合成线程,剩余工作由合成线程完成. **

**合成线程首先对每个图层进行分块,将其划分为更多的小区域. 他会从线程池中那去多个线程来完成分块工作**

---

7. **光栅化 - Raster**

**光栅化是将每个块变成位图, 优先处理靠近视口的快**

**此过程会用到GPU加速**

**合成线程在进行光栅化的时候会将任务交给GPU进程, 让GPU进程完成光栅化, 之后再将光栅化之后的位图交给合成线程**

**合成线程会将块信息交给GPU进程, 以极高的速度完成光栅化, GPU进程会开启多个线程来完成光栅化, 并且有限处理靠近视口区域的块, 光栅化的结果就是一块一块的位图**

---

8. **画 - Draw**

**合成线程计算出每个位图在屏幕上的位置, 交给GPU进行最终呈现**

**合成线程会先生成quad(指引)信息, 包含相对于屏幕的位置信息, 然后将quad信息交给GPU进程, GPU进程在交给硬件(显卡), 由硬件渲染到页面上**

1. 合成线程拿到每个层, 每个块的位图后, 生成一个个quad(指引)信息
2. 指引会标识出每个位图应该画到屏幕的哪个位置, 以及会考虑到旋转, 缩放等变形
3. **变形发生在合成线程, 与渲染主线程无关, 这就是transform效率高的本质原因**
4. 合成线程会吧quad提交给GPU进程, 由GPU进程产生系统调用, 提交给GPU硬件, 完成最终的屏幕成像

---

#### 为什么不由合成线程直接交给硬件?

​	因为合成线程是属于渲染进程里面的一个线程, 渲染进程为了安全是放在沙盒里面的, 和外界是隔离开的, **这样就算浏览器浏览了一个带病毒的网页, 只要不把文件下载到操作系统里, 浏览器被攻击了也不会影响到操作系统, 同时也由于渲染进程在沙盒里, 不能直接操作硬件, 所以要通过GPU进程交给硬件**

---

#### 什么是reflow(重排, 回流)

reflow本质就是重新计算layout树,后群殴

当进行了会影响布局树的操作后, 需要重新计算布局树, 会引发layout,

为了避免连续的多次操作导致布局树反复计算,浏览器会合并这些操作, 当js代码全部完成后在进行统一计算,  所以, 改动属性造成的reflow是异步完成的

也同样因为如此, 当js获取布局属性时, 就可能造成无法获取到最新的布局信息

浏览器在反复权衡下, 最终决定获取属性立即reflow

---

#### 什么是repaint(重绘)

repaint的本质就是重新根据分层信息计算了绘制指令

当改动了可见样式后, 就需要重新计算, 会引发repaint

由于元素的布局信息也属于可见样式, 所以 reflow 一定会引发 repaint

---

#### 为什么transform效率高

因为transform既不会影响布局也不会影响绘制指令, 它影响的只是渲染流程的最后一个 画[draw] 阶段

由于 画[draw] 阶段在合成线程中, 所以transform的变化几乎不会影响渲染主线程, 反之, 渲染主线程无论如何忙碌, 也不会影响transform的变化
